#!/usr/bin/env bash

# Read path to the issue.md file from ARGV
pwd=$1
# Read $2 and transform to an absolute path
issue_file="$(pwd)/$2"
work_dir=$(dirname $issue_file)

cd "$pwd"

# Optionally use APPMAP_COMMAND as the CLI command to run, otherwise use 'appmap'
command=${APPMAP_COMMAND:-appmap}

# Example: LINT_COMMAND="./venv/bin/python -m pylint --errors-only"
# Example: LINT_COMMAND="./venv/bin/python -m flake8"
lint_command=${LINT_COMMAND}

# Example: LINT_ERROR_PATTERN=": E"
lint_error_pattern=${LINT_ERROR_PATTERN}

# Check if issue_file is provided and exists
if [[ -z "$issue_file" ]]; then
  echo "Error: Path to issue.md file is required."
  exit 1
elif [[ ! -f "$issue_file" ]]; then
  echo "Error: File '$issue_file' not found."
  exit 1
fi

plan_file="${work_dir}/plan.md"

# If NOPLAN is absent, transform the issue into a plan
if [[ -z "$NOPLAN" ]]; then
  echo "Transforming issue $issue_file into a plan"
  set -x
  $command navie --log-navie -c $issue_file -o $plan_file "@plan" > "${work_dir}/plan.log" 2>&1
  set +x

  if [[ $? -ne 0 ]]; then
    echo "Error: Failed to transform issue into a plan. See ${work_dir}/plan.log for details."
    exit 1
  fi

  echo "Plan stored in $plan_file"
fi

# If NOLIST is absent, detect files to be modified
if [[ -z "$NOLIST" ]]; then
  echo "Detecting files to be modified"
  set -x
  $command navie --log-navie -c $plan_file -o "${work_dir}/files.json" "@list-files /format=json /nofence" > "${work_dir}/list-files.log" 2>&1
  set +x

  if [[ $? -ne 0 ]]; then
    echo "Error: Failed to detect files to be modified. See ${work_dir}/list-files.log for details."
    exit 1
  fi

  echo "Files to be modified stored in ${work_dir}/files.json"
fi

context_file="${work_dir}/context.txt"
rm -f $context_file
touch $context_file

# Use jq to iterate over the array entries in files.json 
jq -r '.[]' "${work_dir}/files.json" | while read -r file; do
  echo "Collecting source file $file"
  echo "<file>" >> $context_file
  echo "<path>$file</path>" >> $context_file
  echo "<content>" >> $context_file
  cat $file >> $context_file
  echo "</content>" >> $context_file
  echo "</file>" >> $context_file
done

# Generate the code using @generate. Skip if NOGENERATE is present
if [[ -z "$NOGENERATE" ]]; then
  plan_prompt="${work_dir}/plan.txt"
  cat <<PLAN_PROMPT > $plan_prompt
@generate /nocontext /noformat

## Input format

The plan is delineated by the XML <plan> tag.

The source files are delineated by XML <file> tags. Each file has a <path> tag with the file path and a <content> tag with the file content.

Do not treat the XML tags as part of the source code. They are only there to help you parse the context.

## Output format

For each change you want to make, generate a pair of tags called <original> and <modified>.
Wrap these tags with a <change> tag that also includes a <file> tag with the file path.

The <original> tag should contain the original code that you want to change. Do not abbreviate
existing code using ellipses or similar. 

The <original> code should be at least 5 lines long.

Do not output the entire original code if you only want to change a part of it. Output
only the part that you want to change.

The <modified> tag should contain the modified code that you want to replace the original code with.
Do not abbreviate the modified code using ellipses or similar. You must place the exact modified code 
in the <modified> tag.

You do not need to output the entire modified code if you only want to change a part of it. Output
only the part that you want to change.

Both the original code and the output code must contain the proper indentation and formatting.
For example, if the original code has a 4 spaces of indentation, the output code must also have a 4 
spaces of indentation. If the original code has 8 spaces of indentation, the output code must also have
8 spaces of indentation.

The <original> and <modified> content should be wrapped in a CDATA section to avoid XML parsing issues.

## Example output

<change>
  <file>sympy/physics/vector/point.py</file>
  <original>
            except Exception:
                raise ValueError('Velocity of point ' + self.name + ' has not been'
                                 ' defined in ReferenceFrame ' + frame.name)
  </original>
  <modified>
                # Attempt to calculate the velocity based on position's time derivative
                return self.pos_from(self).dt(frame)
            except Exception:
                raise ValueError('Velocity of point ' + self.name + ' has not been'
                                 ' defined in ReferenceFrame ' + frame.name)
  </modified>
</change>

PLAN_PROMPT
  echo "<plan>" >> $plan_prompt
  cat $plan_file >> $plan_prompt
  echo "</plan>" >> $plan_prompt
  cat $context_file >> $plan_prompt

  echo "Solving plan $plan_prompt into code"
  set -x
  $command navie --log-navie -i $plan_prompt -o "${work_dir}/solution.md" > "${work_dir}/generate.log" 2>&1
  set +x

  if [[ $? -ne 0 ]]; then
    echo "Error: Failed to generate code. See ${work_dir}/generate.log for details."
    exit 1
  fi

  echo "Code generated in ${work_dir}/solution.md"
fi

# Apply the generated code changes
if [[ -z "$NOAPPLY" ]]; then
  apply_prompt="${work_dir}/apply.txt"
  cat <<APPLY_PROMPT > $apply_prompt
@apply /all

APPLY_PROMPT
  cat "${work_dir}/solution.md" >> $apply_prompt

  echo "Applying changes to source files"
  set -x
  $command navie --log-navie -i "$apply_prompt" > "${work_dir}/apply.log" 2>&1
  set +x

  if [[ $? -ne 0 ]]; then
    echo "Error: Failed to apply changes to source files. See ${work_dir}/apply.log for details."
    exit 1
  fi

  echo "Changes applied"
fi

if [[ -n "$lint_command" ]]; then
  echo "Linting source files"

  jq -r '.[]' "${work_dir}/files.json" | while read -r file; do
    echo "Linting $file"

    set -x
    # Run the linter and tee the output to a variable and to stdout
    lint_output=$($lint_command $file 2>&1 | tee /dev/tty)
    set +x

    if [[ $? -ne 0 ]]; then
      echo "Error: Failed to lint source files."
    else
      echo "$lint_output"

      if [[ -n "$lint_error_pattern" ]]; then
        # Check the output for presence of errors
        if [[ $lint_output == *"$lint_error_pattern"* ]]; then
          echo "The source file contains linting errors."
          echo "$lint_output"

          # Normalize the file path to replace separator characters with underscores
          norm_file=$(echo $file | tr / _)
          repair_prompt="${work_dir}/repair_${norm_file}.txt"
          repair_plan="${work_dir}/repair_${norm_file}.md"
          repair_log="${work_dir}/repair_${norm_file}.log"
          
          cat <<PLAN_PROMPT > $repair_prompt
@generate /nocontext /noformat

Fix the linter errors indicated by the <lint-error> tag.

## Output format

For each change you want to make, generate a pair of tags called <original> and <modified>.
Wrap these tags with a <change> tag that also includes a <file> tag with the file path.

The <original> tag should contain the original code that you want to change. Do not abbreviate
existing code using ellipses or similar. You must place the exact original code in the <original> tag.

The <original> code should be at least 5 lines long.

The <modified> tag should contain the modified code that you want to replace the original code with.
Do not abbreviate the modified code using ellipses or similar. You must place the exact modified code 
in the <modified> tag.

Both the original code and the output code must contain the proper indentation and formatting.
For example, if the original code has a 4 spaces of indentation, the output code must also have a 4 
spaces of indentation. If the original code has 8 spaces of indentation, the output code must also have
8 spaces of indentation.

The <original> and <modified> content should be wrapped in a CDATA section to avoid XML parsing issues.

## Example output

<change>
  <file>sympy/physics/vector/point.py</file>
  <original>
            except Exception:
                raise ValueError('Velocity of point ' + self.name + ' has not been'
                                 ' defined in ReferenceFrame ' + frame.name)
  </original>
  <modified>
                # Attempt to calculate the velocity based on position's time derivative
                return self.pos_from(self).dt(frame)
            except Exception:
                raise ValueError('Velocity of point ' + self.name + ' has not been'
                                 ' defined in ReferenceFrame ' + frame.name)
  </modified>
</change>

PLAN_PROMPT
          echo "<lint-error>" >> $repair_prompt
          echo $lint_output >> $repair_prompt
          echo "</lint-error>" >> $repair_prompt
          echo "<file>" >> $repair_prompt
          echo "<path>$file</path>" >> $repair_prompt
          echo "<content>" >> $repair_prompt
          cat $file >> $repair_prompt
          echo "</content>" >> $repair_prompt
          echo "</file>" >> $repair_prompt

          # Plan the repair
          echo "Generating code to repair $file"
          set -x
          $command navie --log-navie -i "$repair_prompt" -o "$repair_plan" > $repair_log 2>&1
          set +x

          if [[ $? -ne 0 ]]; then
            echo "Error: Failed to generate code to repair source file. See $repair_log for details."
            exit 1
          fi

          echo "Code generated to repair source file in $repair_plan"

          repair_apply_prompt="${work_dir}/repair_apply_${norm_file}.txt"
          repair_apply_log="${work_dir}/repair_apply_${norm_file}.log"

          cat <<APPLY_PROMPT > $repair_apply_prompt
@apply /all

APPLY_PROMPT
          cat $repair_plan >> $repair_apply_prompt

          echo "Applying changes to source files"
          set -x
          $command navie --log-navie -i "$repair_apply_prompt" > "$repair_apply_log" 2>&1
          set +x

          if [[ $? -ne 0 ]]; then
            echo "Error: Failed to apply changes to source files. See ${repair_apply_log} for details."
            exit 1
          fi

          echo "Changes applied"
        fi
      fi
    fi
  done


  echo "Source files linted."
fi  
